#![feature(proc_macro_span)]
//! The crate offers [`include_display_mode_tex!`] macro that allows to embed tex formulae
//! in documentation generated by `rustdoc` via `cargo doc`.
//! 
//! # What [`include_display_mode_tex!`] can do now and what can be done theoretically
//!
//! In its current implementation, [`include_display_mode_tex!`] macro merely turns
//! the contents of `.tex` files into Markdown with raw LaTeX formulae. For the formulae to be displayed 
//! as such and not LaTeX syntax, Markdown with raw LaTeX must be rendered with some library, such as
//! [`KaTeX`](https://katex.org/docs/autorender.html) or
//! [`MathJax`](http://docs.mathjax.org/en/latest/web/configuration.html). Such approach burdens the crate
//! with extra complexity of `.cargo` config and the requirement to build the documentation via 
//! `cargo doc --no-deps` instead of `cargo doc` **but it works**.
//! 
//! There is also [`katex` crate](https://docs.rs/katex/latest/katex/) that theoretically can allow
//! to render HTML when the documentation is generated. A PR with such functionality will be very
//! welcome (though feature-gated for backward compatibility).
//! 
//! # Setting up the crate (for using [`include_display_mode_tex!`] with [`KaTeX` renderer](https://katex.org/docs/autorender.html))
//! 
//! 1. Create `.cargo` directory in the crate root (the directory containing `Cargo.toml`)
//! 2. In `.cargo`, add [`config.toml`](https://doc.rust-lang.org/cargo/reference/config.html)
//! with the following contents:
//! ```toml
//! [build]
//! rustdocflags = [ "--html-in-header", "./src/html/docs-header.html" ]
//! ```
//! 3. Add these two line to your `Cargo.toml`
//! ```toml
//! [package.metadata.docs.rs]
//! rustdoc-args = [ "--html-in-header", "./src/html/docs-header.html" ]
//! ```
//! 4. Create `./src/html` directory (where `./src/html` is a relative path from the crate root)
//! 5. In `./src/html` add `docs-header.html` with the following contents:
//! ```html
//! <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
//! <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
//! <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
//! <script>
//!     document.addEventListener("DOMContentLoaded", function() {
//!         renderMathInElement(document.body, {
//!             delimiters: [
//!                 {left: "$$", right: "$$", display: true},
//!                 {left: "\\(", right: "\\)", display: false},
//!                 {left: "$", right: "$", display: false},
//!                 {left: "\\[", right: "\\]", display: true}
//!             ]
//!         });
//!     });
//! </script>
//! ```
//!
//! # Example
//!
//! ```no_run
//! use include_display_mode_tex::include_display_mode_tex;
//! 
//! #[doc = include_display_mode_tex!("./tex/example.tex")]
//! # let s = 0;
//! ```
//! 
//! Notice that the path is relative not to the crate root but to the call site and that
//! the documentation must be built with 
//! ```text
//! cargo doc --no-deps
//! ```
//! 
//! # Sources of inspiration
//!
//! Other include\* macros:
//! * [`core::include_str`]
//! * [`core::include_bytes`]
//! * [`core::include`]
//! * [`include_dir::include_dir`](https://crates.io/crates/include_dir)
//! 
//! Special thanks to [`victe`](https://github.com/victe) for providing 
//! [`rust-latex-doc-minimal-example`](https://github.com/victe/rust-latex-doc-minimal-example)

extern crate proc_macro;

use std::io::Read;

use proc_macro::TokenStream;
use quote::quote;
use relative_path::RelativePath;

mod args;

use args::{Args, Error, PresumedPathToTex, TryGetArgs};

// At the time of writing, proc_macro doesn't offer a way to obtain call site purely
//
// Read about pure and impure functions functions here:
// https://en.wikipedia.org/wiki/Pure_function
fn impurely_get_call_site_dir() -> std::path::PathBuf {
    let call_site: std::path::PathBuf = proc_macro::Span::call_site().source_file().path();
    call_site
        .parent()
        // unwrap won't panic because even if a crate is placed in root,
        // rust files are stored in crate_folder/src/
        .unwrap()
        // It's very likely that there will be unnecessary copying as
        // compilers struggle to perform allocation-related optimizations
        .to_path_buf()
}

impl PresumedPathToTex {
    // The function is called canonicalize_... and not try_canonicalize_... to be consistent with
    // std::fs::canonicalize that also returns std::io::Result<T>.
    fn canonicalize_with_respect_to_call_site_dir(
        self,
        call_site_dir: std::path::PathBuf,
    ) -> std::io::Result<CanonicalizedPresumedPathToTex> {
        // The presumed path to tex has to be made absolute first because only then
        // std::fs::canonicalize() will resolve the path with respect to the macro call site dir
        // and not with respect to the current working directory
        let abs_presumed_path_to_tex: std::path::PathBuf = if self.0.is_relative() {
            let rel_path_from_call_site_to_presumed_tex_file =
                RelativePath::new(self.0.as_os_str().to_str().unwrap());
            rel_path_from_call_site_to_presumed_tex_file.to_logical_path(call_site_dir)
        } else {
            self.0
        };

        abs_presumed_path_to_tex
            .canonicalize()
            .map(CanonicalizedPresumedPathToTex)
    }
}

struct CanonicalizedPresumedPathToTex(std::path::PathBuf);

trait TryReadAsTexFile {
    fn try_read_as_tex_file(self) -> std::io::Result<TexFileContents>;
}

impl TryReadAsTexFile for std::io::Result<CanonicalizedPresumedPathToTex> {
    fn try_read_as_tex_file(self) -> std::io::Result<TexFileContents> {
        let canonicalized_presumed_path_to_tex: CanonicalizedPresumedPathToTex = self?;
        let path = canonicalized_presumed_path_to_tex.0.as_path();
        let mut file = std::fs::File::open(path)?;
        let mut buffer: String = String::new();
        file.read_to_string(&mut buffer)?;
        Ok(TexFileContents(buffer))
    }
}

struct TexFileContents(String);

impl TexFileContents {
    fn into_markdown_tex(self) -> MarkdownTex {
        let backslash_count = self.0.chars().filter(|c| c == &'\\').count();
        let mut escaped_string_buffer = String::with_capacity(backslash_count + "$$$$".len());
        escaped_string_buffer += "$$";
        for c in self.0.chars() {
            core::iter::repeat(())
                .take(if c == '\\' { 2 } else { 1 })
                .for_each(|_| escaped_string_buffer.push(c));
        }
        escaped_string_buffer += "$$";
        MarkdownTex(escaped_string_buffer)
    }
}

struct MarkdownTex(String);

trait IntoTokenStream {
    fn into_token_stream(self) -> TokenStream;
}

impl IntoTokenStream for std::io::Result<MarkdownTex> {
    fn into_token_stream(self) -> TokenStream {
        match self {
            Ok(markdown_tex) => {
                let s = markdown_tex.0;
                quote! { #s }
            }
            Err(e) => {
                let error_message = e.to_string();
                quote! { #error_message }
            }
        }
        .into()
    }
}

/// Read the crate documentation for details
#[proc_macro]
pub fn include_display_mode_tex(ts: TokenStream) -> TokenStream {
    let Args{ presumed_path_to_tex } = match ts.try_get_args() {
        Ok(args) => args,
        Err(e) => {
            return match e {
                Error::TheMacroAcceptsOnlyOneArgument => quote! {
                    compile_error!(concat!(stringify!(include_display_mode_tex), " accepts only one argument")) 
                },
                Error::TheMacroExpectedAnArgument => quote! {
                    compile_error!(concat!(stringify!(include_display_mode_tex), " expected an argument, specifically a string literal")) 
                },
                Error::TheOnlyArgumentMustBeAStringLiteral => quote! {
                    compile_error!(concat!(stringify!(include_display_mode_tex), " expected a string literal as an argument")) 
                }
            }.into()
        }
    };

    presumed_path_to_tex
        .canonicalize_with_respect_to_call_site_dir(impurely_get_call_site_dir())
        // No validation occurs because it would slow down compilation times
        .try_read_as_tex_file()
        .map(TexFileContents::into_markdown_tex)
        .into_token_stream()
}
